package com.identity.processing.udf;

import org.apache.spark.sql.api.java.UDF8;
import org.apache.spark.sql.types.DataTypes;

import java.util.HashMap;
import java.util.Map;

/**
 * A UDF for name matching that compares client names with TU names using various criteria.
 */
public class NameMatchingUDF implements UDF8<String, String, String, String, String, String, String, String, String[]> {

    private static final Map<String, String> PREFERRED_NAMES_MAP = loadPreferredNames();

    /**
     * Main logic for name matching UDF.
     *
     * @param clientFirstName    Client's first name.
     * @param clientLastName     Client's last name.
     * @param clientMiddleName   Client's middle name.
     * @param clientMiddleInitial Client's middle initial.
     * @param tuFirstName        TU's first name.
     * @param tuLastName         TU's last name.
     * @param tuMiddleName       TU's middle name.
     * @param tuMiddleInitial    TU's middle initial.
     * @return Array containing rank and matchkey.
     */
    @Override
    public String[] call(String clientFirstName, String clientLastName, String clientMiddleName, String clientMiddleInitial,
                         String tuFirstName, String tuLastName, String tuMiddleName, String tuMiddleInitial) {

        String fnFlag = compareNames(clientFirstName, tuFirstName);
        String lnFlag = compareNames(clientLastName, tuLastName);
        String mnFlag = compareNames(clientMiddleName, tuMiddleName);
        String miFlag = compareInitials(clientMiddleInitial, tuMiddleInitial);

        // Construct matchkey
        String matchkey = fnFlag + lnFlag + mnFlag + miFlag;

        // Determine rank based on matchkey
        int rank = getRankFromMatchKey(matchkey);

        return new String[]{String.valueOf(rank), matchkey};
    }

    /**
     * Compares two names based on direct match, preferred names, and soundex.
     *
     * @param clientName Client's name.
     * @param tuName     TU's name.
     * @return Match flag: "Y" (Match), "N" (Non-match), "I" (Incomplete).
     */
    private String compareNames(String clientName, String tuName) {
        if (clientName == null || tuName == null) {
            return "I"; // Incomplete if either side is null
        }

        if (clientName.equalsIgnoreCase(tuName)) {
            return "Y"; // Direct match
        }

        String clientPreferred = PREFERRED_NAMES_MAP.getOrDefault(clientName.toLowerCase(), clientName);
        String tuPreferred = PREFERRED_NAMES_MAP.getOrDefault(tuName.toLowerCase(), tuName);

        if (clientPreferred.equalsIgnoreCase(tuPreferred)) {
            return "Y"; // Preferred name match
        }

        if (getSoundex(clientName).equals(getSoundex(tuName))) {
            return "Y"; // Soundex match
        }

        return "N"; // Non-match
    }

    /**
     * Compares two initials.
     *
     * @param clientInitial Client's initial.
     * @param tuInitial     TU's initial.
     * @return Match flag: "Y" (Match), "N" (Non-match), "I" (Incomplete).
     */
    private String compareInitials(String clientInitial, String tuInitial) {
        if (clientInitial == null || tuInitial == null) {
            return "I"; // Incomplete if either side is null
        }

        if (clientInitial.equalsIgnoreCase(tuInitial)) {
            return "Y"; // Match
        }

        return "N"; // Non-match
    }

    /**
     * Retrieves rank based on the matchkey.
     *
     * @param matchkey Matchkey generated by comparing names.
     * @return Rank as an integer.
     */
    private int getRankFromMatchKey(String matchkey) {
        Map<String, Integer> matchkeyRankMap = new HashMap<>();
        matchkeyRankMap.put("YYYY", 1);
        matchkeyRankMap.put("YYYN", 2);
        matchkeyRankMap.put("YYNY", 3);
        // Add additional mappings based on the Excel sheet
        return matchkeyRankMap.getOrDefault(matchkey, 99); // Default rank for unmatched keys
    }

    /**
     * Loads the preferred names file into a map.
     *
     * @return Map of nicknames to preferred names.
     */
    private static Map<String, String> loadPreferredNames() {
        Map<String, String> preferredNames = new HashMap<>();
        // Example of hardcoded values for demonstration
        preferredNames.put("jon", "john");
        preferredNames.put("mike", "michael");
        preferredNames.put("kate", "katherine");
        // Load actual data from preferred_names.txt
        return preferredNames;
    }

    /**
     * Calculates the Soundex code for a given string.
     *
     * @param name Input string.
     * @return Soundex code.
     */
    private String getSoundex(String name) {
        if (name == null || name.isEmpty()) {
            return "";
        }

        char[] soundex = new char[4];
        char firstLetter = Character.toUpperCase(name.charAt(0));

        // Soundex encoding rules
        char[] mapping = "01230120022455012623010202".toCharArray();
        soundex[0] = firstLetter;
        int count = 1;

        for (int i = 1; i < name.length() && count < 4; i++) {
            char c = Character.toUpperCase(name.charAt(i));
            if (c >= 'A' && c <= 'Z') {
                int mapped = mapping[c - 'A'];
                if (mapped != '0' && mapped != soundex[count - 1]) {
                    soundex[count++] = (char) mapped;
                }
            }
        }

        // Fill with 0s if less than 4 characters
        while (count < 4) {
            soundex[count++] = '0';
        }

        return new String(soundex);
    }
}
